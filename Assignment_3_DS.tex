\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{color}
\usepackage{float}
\usepackage{geometry}
\geometry{a4paper}
\geometry{margin = .5in}

\usepackage{graphicx}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{
  language=C++,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{mauve},
  commentstyle=\color{dkgreen},
  stringstyle=\color{blue},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}


\title{Assignment 3 Accompanying Document}
\author{Harry Haisty}
\date{November 2018}

\begin{document}

\maketitle

\section*{Section 3.1}

\begin{enumerate}
    \item \begin{enumerate}
    \item[a.] $\{1, 2, 3, 5\}$
    \item[b.] $\{3\}$
    \item[c.] $\{2,4\}$
    \item[d.] $\{1\}$
    \item[e.] $\{5, 2\}$
    \item[f.] No, Z does not contain the value 1.
\end{enumerate}

    \item \begin{enumerate}
        \item
    \end{enumerate}
\end{enumerate}



\section*{Section 3.2}
\begin{enumerate}
    %%%%%%%%%%%
    
    \item[a.] 
    \begin{lstlisting}
sum = 0;
for (int i = 0; i < n; i++)
  for (int j = 0; j < n * n; j++)
    sum++;
    \end{lstlisting}
    
    \item[answer:] This code runs $n^2$ times.
    %%%%%%%%%%%%
    
    \item[b.]
    \begin{lstlisting}
long fib (long index)
{
  if (index == 0)		// Base case
    return 0;
  else if (index == 1)		// Base case
    return 1;
  else				// Reduction and recursive calls
    return fib (index b - 1) + fib (index b - 2);
}
    \end{lstlisting}
    
    %%%%%%%%%%%%%%
    
    \item[c.]
    \begin{lstlisting}
int gcd (int m, int n)
{
    if (m % n == 0)
        return n;
    else
       return gcd (n, m % n);
}
    \end{lstlisting}
    
    %%%%%%%%%%%%%%%
    
    \item[d.]
    \begin{lstlisting}
sum = 0;
for (int i = 0; i < n; i++)
  for (int j = 0; j < i * i; j++)
    for (int k = 0; k < j; k++)
  sum++;
    \end{lstlisting}
    
    \item[answer:] This code runs $n^5$ times.
    
    %%%%%%%%%%%%%%%%%%
    
    \item[e.]
    \begin{lstlisting}
sum = 0;
for (int i = 1; i < n; i++)
  for (int j = 1; j < i * i; j++)
    if (j % i == 0)
  for (k = 0; k < j; k++)
    sum++;
    \end{lstlisting}
    
    \item[answer:] This code runs $n^4$ times.
    
\end{enumerate}

\section*{Section 3.4}
\begin{figure}[h]
    \centering
    \includegraphics[width=7cm]{treepart1}
    \caption{Original tree}
    \label{fig:my_label}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=7cm]{treepart2}
    \caption{After 10 is added to tree}
    \label{fig:my_label}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=7cm]{treepart3}
    \caption{After 15 is removed from tree}
    \label{fig:my_label}
\end{figure}

\section*{Section 3.5}
\begin{figure}
    \centering
    \includegraphics[width = 11cm]{binarytreewithd}
    \caption{Binary tree with node D added}
    \label{fig:my_label}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width = 11cm]{rearrangetree}
    \caption{Reordered binary tree}
    \label{fig:my_label}
\end{figure}


\section*{Section 3.6}
I used the \textbf{Merge Sort} algorithm to sort this data set.
\begin{figure}
    \centering
    \includegraphics[width= 7cm]{mergesort}
    \caption{My merge sort figure for the data set}
    \label{fig:my_label}
\end{figure}

\section*{Section 3.7}

\begin{enumerate}

\item List all the paths from A to H 
\begin{enumerate}
    \item[] A, B, D, H
    \item[] A, B, D, F, H
    \item[] A, C, F, H
    \item[] A, C, B, D, H
    \item[] A, E, B, D, H
    \item[] A, E, G, H
\end{enumerate}

\item which paths have the lowest weight?
\begin{enumerate}
    \item[] A, C, F, H
    \item[] A, B, D, F, H
    \item[] A, E, G, H
\end{enumerate}
These paths all have a weight of 31. 

\item Which path has the shortest length?
\begin{enumerate}
    \item[] A, C, F, H
    \item[] A, B, D, H
    \item[] A, E, G, H
\end{enumerate}
These paths all are of length 4.

\item Is the graph connected strongly or weakly? Explain. \newline 
It is connected weakly because the paths only go one direction, which means that there is no connecting path between any two nodes.  

\end{enumerate}

\section*{Section 3.8}
\begin{enumerate}
    \item a breadth-first search \newline
    A, B, C, D, E, F
    
    \item a depth-first search \newline
    A, B, E, C, F, D
    
    \item make an adjacency list
    
    \item make an adjacency matrix
    \begin{figure}
        \centering
        \includegraphics[width = 8cm]{adjacencymatrix}
        \caption{Adjacency matrix for 3.8}
        \label{fig:my_label}
    \end{figure}
    \item make an incidence matrix for this graph
    \begin{figure}
        \centering
        \includegraphics[width = 8cm]{incidencematrix}
        \caption{Incidence matrix for this graph}
        \label{fig:my_label}
    \end{figure}
    
    \item identify a cycle in the graph \newline
    There is a cycle between vertices A, B, and C.
    
    \item Is the graph complete? Explain. \newline
    This graph is not complete, there are not paths between each node.
    
    \begin{figure}
        \centering
        \includegraphics[width=6cm]{completegraph}
        \caption{The red lines represent the missing paths in order to make this graph "complete"}
        \label{fig:my_label}
    \end{figure}
\end{enumerate}

\section*{Section 3.9}
\begin{figure}
    \centering
    \includegraphics[width = 11cm]{abstractsubmission}
    \caption{My 2019 NCUR abstract submission}
    \label{fig:my_label}
\end{figure}

I couldn't make it to either of the abstract writing workshops, but I was able to get in touch with the people in the Technical Communication department here at KSU. They gave me tons of really good writing tips, and helped me edit my abstract so that I could submit it. I have submitted it to NCUR, ACM, and IEEE. 

\section*{Section 3.10}

\subsection*{The Code}
\begin{lstlisting}

//methods.h
using namespace std;

class mixed_number_operations {

public :
    float regular_number, complex_number;

    void printNumber() {
        if (complex_number > 0) {
            cout << regular_number << "+" << complex_number << "i";
        } else {
            cout << regular_number << "" << complex_number << "i";
        }
    }

    void add_numbers(mixed_number_operations first, mixed_number_operations second) {
        regular_number = first.regular_number + second.regular_number;
        complex_number = first.complex_number + second.complex_number;
        if (complex_number > 0) {
            cout << regular_number << "+" << complex_number << "i";
        } else {
            cout << regular_number << "" << complex_number << "i";
        }
    }

    void subtract_numbers(mixed_number_operations one, mixed_number_operations two) {
        regular_number = one.regular_number - two.regular_number;
        complex_number = one.complex_number - two.complex_number;
        if (complex_number > 0) {
            cout << setprecision(2);
            cout << regular_number << "+" << complex_number << "i";
        } else {
            cout << setprecision(2);
            cout << regular_number << complex_number << "i";
        }
    }

    void multiply_numbers(mixed_number_operations one, mixed_number_operations two) {
        regular_number = one.regular_number * two.regular_number;
        complex_number = one.complex_number * two.complex_number;
        if (complex_number > 0) {
            cout << regular_number << "+" << complex_number << "i";
        } else {
            cout << regular_number << "" << complex_number << "i";
        }
    }

    void divide_numbers(mixed_number_operations one, mixed_number_operations two) {
        if (two.regular_number == 0 || two.complex_number == 0) {
            cout << "Sorry division by 0 is not possible";
        } else {
            regular_number = one.regular_number / two.regular_number;
            complex_number = one.complex_number / two.complex_number;
            if (complex_number > 0) {
                cout << regular_number << "+" << complex_number << "i";
            } else {
                cout << regular_number << "" << complex_number << "i";
            }
        }
    }

    void printing_results(mixed_number_operations first_value, mixed_number_operations second_value) {

        cout << endl << "1. The FIRST complex number is: "; first_value.
                printNumber();

        cout << endl << "2. The SECOND complex number is: "; second_value.
                printNumber();

        cout << endl << "3. The SUM of the complex numbers is: ";
                add_numbers(first_value, second_value);

        cout << endl << "4. The MULTIPLICATION of the complex numbers is: ";
                multiply_numbers(first_value, second_value);

        cout << endl << "5. The SUBTRACTION of the complex number is: ";
                subtract_numbers(first_value, second_value);

        cout << endl << "6. The DIVISION of the complex numbers is: ";
                divide_numbers(first_value, second_value);

        cout << endl;
    }
};

//main.cpp

#include <iostream>
#include <math.h>
#include<iomanip>
#include "methods.h"

using namespace std;

int main() {
    mixed_number_operations first_input_value, second_input_value;

    //prompts user to enter integer part of rational number
    cout << "Enter integer part of first normal number: ";
    cin >> first_input_value.regular_number;

    //prompts user to enter integer part of complex number (minus i)
    cout << "Enter integer value of complex number(*not* including the letter i): ";
    cin >> first_input_value.complex_number;

    //prompts user to enter integer part of second rational number
    cout << "Enter integer part of second normal number: ";
    cin >> second_input_value.regular_number;

    //prompts uer to enter integer part of second complex number (minus i)
    cout << "Enter integer part of second complex number (*not* including the letter i): ";
    cin >> second_input_value.complex_number;

    //calls printing method to display results of method calls.
    first_input_value.printing_results(first_input_value, second_input_value);
}

\end{lstlisting}

\begin{figure}[h]
    \centering
    \includegraphics[width = 12cm]{310result}
    \caption{code output for section 3.10}
    \label{fig:my_label}
\end{figure}

\section*{Section 3.11}
\subsection*{The Rationale}
The function of this program was to accept a user-defined set of data that I would parse through and determine different set-related qualities. I was looking for the union, the intersection, the difference, and the change in these different sets. The user can input an infinite amount of numbers and the code is able to handle however many integers they decide to include. It uses for loops to parse through the different vectors and determine whether or not there are elements that duplicate, and assigns a corresponding action to those different scenarios. 

\subsection*{The IDE}
I chose to use Clion for this project because I am most familiar with its structure and interface. I tried to port some of my .cpp files to Visual Studio, but they are not as easily transferrable unless they are in .sln format. I have found that saving my .cpp files in my local repositories and making sure that my Clion configuration is standard across my computers is the safest way to be able to code on multiple machines.

\subsection*{The Code}
\begin{lstlisting}
#include <iostream>
#include <array>
#include <vector>

using namespace std;

//method to set union of two sets
void union_operator(std::vector<int> first, std::vector<int> second) {
    std::vector<int> mega_vector;

    //loops through and populates larger vector with elements from vector 1
    for (int i = 0; i < first.size(); i++) {
        mega_vector.push_back(first[i]);

        //loops through and determines if any elements from second vector duplicate first vector
        for (int j = 0; j < second.size(); j++) {
            if (second[j] == first[i])
                //erases duplicate elements
                second.erase(second.begin() + j);
        }
    }

    //adds resized vector to mega vector
    for (int k = 0; k < second.size(); k++)
        mega_vector.push_back(second[k]);

    //prints contents of mega vector
    for (int l = 0; l < mega_vector.size(); l++)
        cout << mega_vector[l] << " ";
}

//method to determine intersection of two sets
void intersection_operator(std::vector<int> first, std::vector<int> second) {
    std::vector<int> micro_vector;

    //loops through first vector
    for (int i = 0; i < first.size(); i++) {
        //loops through second vector and identifies duplicates
        for (int j = 0; j < second.size(); j++) {
            if (second[j] == first[i]) {
                //adds duplicates to micro vector
                micro_vector.push_back(second[j]);
            }
        }
    }

    //prints contents of micro vector
    for (int m = 0; m < micro_vector.size(); ++m) {
        cout << micro_vector[m] << " ";
    }
}

//method to determine difference of two sets
void minus_operator(std::vector<int> first, std::vector<int> second) {
    //loops through first set
    for (int i = 0; i < first.size(); i++)
        //loops through second set
        for (int j = 0; j < second.size(); j++)
            //erases elements that overlap from sets
            if (second[j] == first[i])
                first.erase(first.begin() + i);

    //prints newly resized first array
    for (int k = 0; k < first.size(); k++) {
        cout << first[k] << " ";
    }
}

//method to determine change in two sets
void delta_operator(std::vector<int> first, std::vector<int> second) {
    std::vector<int> vector_nonoverlapping;

    //loops through first vector
    for (int i = 0; i < first.size(); i++) {
        //loops through second vector
        for (int j = 0; j < second.size(); j++) {
            //erases duplicates from both lists
            if (second[j] == first[i]) {
                first.erase(first.begin() + i);
                second.erase(second.begin() + j);
            }
        }
    }

    //adds nonoverlapping elements from first vector to list
    for (int k = 0; k < first.size(); k++)
        vector_nonoverlapping.push_back(first[k]);
    //adds nonoverlapping elements from second vector to list
    for (int l = 0; l < second.size(); ++l)
        vector_nonoverlapping.push_back(second[l]);
    //prints final list
    for (int m = 0; m < vector_nonoverlapping.size(); m++)
        cout << vector_nonoverlapping[m] << " ";
}

int main() {

    //declare two vector variables
    std::vector<int> vector_1;
    std::vector<int> vector_2;

    //sentinal value for user input
    int input = -1;

    //print message to console to prompt user to populate list
    cout << "We're going to populate our first list, press 0 to complete list: \n";

    //set condition for loop
    while (true) {
        //prompt user for input
        cout << "Enter an integer: ";
        //accept user input
        cin >> input;

        //set condition for break
        if (input == 0)
            break;
        //else continue looping
        else
            vector_1.push_back(input);
    }

    //reset sentinal value since input will be set to 0
    input = -1;

    //prompt user for second set of values
    cout << "Now we're going to populate out second list, press 0 to complete list: ";

    //set condition for loop
    while (true) {

        //prompt user for input
        cout << "Enter an integer: ";
        //accept user input
        cin >> input;

        //set condition for break
        if (input == 0)
            break;
        //else continue looping
        else
            vector_2.push_back(input);
    }

    //print format for union method
    cout << "1. The UNION of these sets is: ";
    //call union subroutine
    union_operator(vector_1, vector_2);

    //print format for intersection method
    cout << "\n2. The INTERSECTION of these sets is: ";
    //call intersection subroutine
    intersection_operator(vector_1, vector_2);

    //print format for subtraction method
    cout << "\n3. The SUBTRACTION of these sets is: ";
    //call minus subroutine
    minus_operator(vector_1, vector_2);

    //print format for delta method
    cout << "\n4. The DELTA of these sets is: ";
    //call delta subroutine
    delta_operator(vector_1, vector_2);
}
\end{lstlisting}

\begin{figure}
    \centering
    \includegraphics[width = 11cm]{311result}
    \caption{result of 3.11 code}
    \label{fig:my_label}
\end{figure}


\section*{Section 3.12}

\subsection*{The Code}

\begin{lstlisting}
//deque Demo
#include <iostream>
#include <list>
#include <algorithm>
#include <deque>
#include <string>

using namespace std;

//creates standard template
template<class T>

void printDeque(const deque<T> &lst, string s) {
    //prints formatting for output
    cout << s << ": ";
    //calls generic template type at first index
    typename deque<T>::const_iterator i = lst.begin();
    //iterates through templated input
    for (; i != lst.end(); i++)
        //outputs addressed value
        cout << *i << ' ';
    cout << endl;
}

int main() {
    //call template
    deque<int> dq1;

    //push value 1 to front of deque {1}
    dq1.push_front(1);

    //push value 2 to front of deque {2, 1}
    dq1.push_front(2);

    //push value 3 to back of deque {2, 1, 3}
    dq1.push_back(3);

    //push value 4 to back of deque {2, 1, 3, 4}
    dq1.push_back(4);

    //prints out deque so far and "dql" identifier
    printDeque(dq1, "dq1");

    //calls generic template type with int
    deque<int> dq2(dq1.begin() + 1, dq1.end() - 1);

    //sets value at index 1 to 5
    dq1[1] = 5;

    //erases value at beginning of deque
    dq1.erase(dq1.begin());

    //adds new elements at specified positions
    dq1.insert(dq1.end() - 1, 2, 6);

    //calls sort function for deque
    sort(dq1.begin(), dq1.end());

    //calls generic template with type int
    deque<int> dq3;

    //resizes dq3 so that it contains the number of elements in dq1 and dq2 combined
    dq3.resize(dq1.size() + dq2.size());

    //merges all three dq's together
    merge(dq1.begin(), dq1.end(), dq2.begin(), dq2.end(), dq3.begin());

    //prints values of deques
    printDeque(dq1, "dq1");
    printDeque(dq2, "dq2");
    printDeque(dq3, "dq3");
    return 0;
}
\end{lstlisting}

\begin{figure}[h]
    \centering
    \includegraphics[width = 11cm]{312Output}
    \caption{Output for section 3.12}
    \label{fig:my_label}
\end{figure}

\section*{Section 3.13}
\subsection*{A. The Commented Code}
\begin{lstlisting}
#include <iostream>
using namespace std;

//set constant integer as sentinal value 1000
static const int N = 1000;

int main()
{
    //initialize array
    int i, a[N];
    
    //loop through array starting with the 2nd element
    for (i = 2; i < N; i++) a[i] = 1;
    
    //loop through array
    for (i = 2; i < N; i++)
        if (a[i])
            //set int j to int i value, multiply j by i until it reaches 1000, set element at i*j to 0
            for (int j = i; j*i < N; j++) a[i*j] = 0;
    //loop through populated array
    for (i = 2; i < N; i++)
        if (a[i]) cout << " " << i;
    cout << endl;
}
\end{lstlisting}

\section{Section 3.13}
\begin{lstlisting}
#include <iostream>

using namespace std;

//create node struct
struct node {
    int val;
    //point to next value
    node *next;

    //call node function and pass int val
    node(int val) {
        //initialize val
        this->val = val;
        //remove addressed data from next
        this->next = nullptr;
    }
};

//declare constant integer N
static const int N = 1000;

int main() {
    int i;
    //address head of node with new node of val 0
    node *head(new node(0)), *current(head);
    //set next node to next val
    current->next = new node(0);
    current = current->next;
    //populate list
    for (i = 2; i < N; i++) {
        current->next = new node(1);
        current = current->next;
    }

    //set current to two nodes down
    current = head->next->next;
    for (i = 2; i < N; i++) {
        //set conditional
        if (current->val) {
            for (int j = i; j * i < N; j++) {
                node *temp(head);
                for (int k = 0; k < j * i; k++) {
                    temp = temp->next;
                }
                temp->val = 0;
            }
        }
        current = current->next;
    }

    //move down list
    current = head->next->next;
    for (i = 2; i < N; i++) {
        //print output
        if (current->val) {
            cout << i << " ";
        }
        current = current->next;
    }
    cout << endl;
}
\end{lstlisting}

\section*{Section 3.14}
\begin{lstlisting}
#include <iostream>
#include <list>
#include <algorithm>
#include <functional>
#include <string>

using namespace std;

//generic template
template<class T>
//vod return method that takes in generic template type and string val
void printList(const list<T> &lst, string s) {
    //prints title of list
    cout << s << ":  ";
    //loops through to print contents of list
    for (typename list<T>::const_iterator i = lst.begin(); i != lst.end(); i++)
        //formats to include space in list
        cout << *i << ' ';
    //ends line
    cout << endl;
}

int main() {
    //declare lst1 with no values
    list<int> lst1;

    //print empty lst1
    printList(lst1, "lst1");

    //call template and populate with 3 value 7's
    list<int> lst2(3, 7);

    //print contents of lst2
    printList(lst2, "lst2");

    //loop through 5 times to populate lst1
    for (int j = 1; j <= 5; j++)
        //push back iterated values onto lst1
        lst1.push_back(j);

    //call template to make list of type int
    list<int>::iterator i1 = lst1.begin(), i2 = i1, i3;

    //increment i2
    i2++;
    i2++;
    i2++;

    //call template to make lst3, increment add value of i2 i1
    list<int> lst3(++i1, i2);

    //print contents of lst3
    printList(lst3, "lst3");

    //call template to create lst4
    list<int> lst4(lst1);

    //print contents of lst4
    printList(lst4, "lst4");

    //set i1 to first value in lst4
    i1 = lst4.begin();

    //transfers elements from lst2 into position in lst4
    lst4.splice(++i1, lst2);

    //print contents of lst2
    printList(lst2, "lst2");

    //print new contents of lst4
    printList(lst4, "lst4");

    //set lst2 to lst1
    lst2 = lst1;

    //print contents of lst2
    printList(lst2, "lst2");

    //set value of i2 to fist value in lst2
    i2 = lst2.begin();

    //transfers element from lst2 into lst4 at between posititon i1 and i2+1
    lst4.splice(i1, lst2, ++i2);

    //print contents of lst2
    printList(lst2, "lst2");

    //print contents of lst4
    printList(lst4, "lst4");

    //set i2 to element at beginning of lst2
    i2 = lst2.begin();

    //set i3 to val i2
    i3 = i2;

    //transfer elements from lst2 into lst4
    lst4.splice(i1, lst2, i2, ++i3);

    //print contents of lst2
    printList(lst2, "lst2");

    //print contents of lst4
    printList(lst4, "lst4");

    //remove elements of value 1 from lst4
    lst4.remove(1);

    //print contents of lst4
    printList(lst4, "lst4");

    //implement sorting algorithm for lst4
    lst4.sort();

    //print contents of lst4
    printList(lst4, "lst4");

    //remove consecutive duplicates in lst4
    lst4.unique();

    //print contents of lst4
    printList(lst4, "lst4");

    //merge contents of lst1 and lst2
    lst1.merge(lst2);

    //print contents of lst1
    printList(lst1, "lst1");

    //print empty lst2
    printList(lst2, "lst2");

    //reverse conents of lst3
    lst3.reverse();

    //print new order of lst3
    printList(lst3, "lst3");

    //reverse contents of lst4
    lst4.reverse();

    //print contents of lst4
    printList(lst4, "lst4");

    //merge lst3 with lst4
    lst3.merge(lst4, greater<int>());

    //print new contents of lst3
    printList(lst3, "lst3");

    //print new emprty contents of lst4
    printList(lst4, "lst4");

    //remove all elements from lst3 that are not equal to 3
    lst3.remove_if(bind2nd(not_equal_to<int>(), 3));

    //print contents of lst3
    printList(lst3, "lst3");

    //check for uniqueness
    lst3.unique(not_equal_to<int>());

    //print contents of lst3
    printList(lst3, "lst3");
    return 0;
}
\end{lstlisting}

\begin{figure}[h]
    \centering
    \includegraphics[width = 10cm]{314Output}
    \caption{Output for code in 3.14}
    \label{fig:my_label}
\end{figure}

\end{document}
